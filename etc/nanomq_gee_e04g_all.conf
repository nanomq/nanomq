# NanoMQ Configuration 0.18.0

# #============================================================
# # NanoMQ Broker
# #============================================================

system {
	parallel = 64
	hook_ipc_url = "ipc:///tmp/nanomq_hook.ipc"
	exchange_ipc_url = "ipc:///tmp/nanomq_exchange.ipc"
	cmd_ipc_url = "ipc:///tmp/nanomq_cmd.ipc"
}

mqtt {
	property_size = 32
	max_packet_size = 255MB
	max_mqueue_len = 2048
	retry_interval = 5s
	keepalive_multiplier = 1.5

	# Three of below, unsupported now
	max_inflight_window = 2048
	max_awaiting_rel = 10s
	await_rel_timeout = 10s
}

listeners.tcp {
	bind = "127.0.0.1:1883"
}

# listeners.ssl {
#	bind = "127.0.0.1:8883"
#	keyfile = "/etc/certs/key.pem"
#	certfile = "/etc/certs/cert.pem"
#	cacertfile = "/etc/certs/cacert.pem"
#	verify_peer = false
#	fail_if_no_peer_cert = false
# }

http_server {
	port = 8081
	limit_conn = 2
	username = admin
	password = public
	auth_type = no_auth
}

log {
	to = [file]
	level = info
	dir = "./log/"
	file = "nanomq.log"
	rotation {
		size = 10MB
		count = 5
	}
}

auth {
	allow_anonymous = true
	no_match = allow
	deny_action = ignore

	cache = {
		max_size = 32
		ttl = 1m
	}

}
# #====================================================================
# # MQTT Broker Bridge
# #====================================================================

bridges.mqtt.emqx1 {
	server = "mqtt-tcp://broker.emqx.io:1883"
	proto_ver = 4
	keepalive = 30s
	backoff_max = 10s
	clean_start = false
	username = admin
	password = "kJyntc8m7ntG+XeO59wz9AAAAAAAAAAAAAAAAAAAAAA/PPcY9MTVF+Y="
	password_encrypted = true
	ssl {
		keyfile = "/bigdata/data/sdv-flow/file1"
		certfile = "/bigdata/data/sdv-flow/file2"
		cacertfile = "/bigdata/data/sdv-flow/file3"
		cert_encrypted = true
	}
	forwards = [
		{
			remote_topic = ""
			local_topic = "ecp/#"
		},
		{
			remote_topic = ""
			local_topic = "$file/#"
		},
		{
			remote_topic = ""
			local_topic = "result/#"
		},
		{
			remote_topic = ""
			local_topic = "ek/#"
		}
	]
	subscription = [
		{
			remote_topic = "agent/${VIN}/metric"
			local_topic = ""
			qos = 1
		}
		{
			remote_topic = "agent/${VIN}/register/response"
			local_topic = ""
			qos = 1
		}
		{
			remote_topic = "agent/${VIN}/proxy/request/+"
			local_topic = ""
			qos = 1
		}
		{
			remote_topic = "agent/${VIN}/fileupload"
			local_topic = ""
			qos = 1
		}
	]

	max_parallel_processes = 8
	max_send_queue_len = 5400
	max_recv_queue_len = 1024
	resend_interval = 1500
	resend_wait = 25000
	cancel_timeout = 3600000
}

webhook {
    url = "http://127.0.0.1:14260/api/sdv-flow/webhook_trigger"
    headers.content-type = "application/json"
    body.encoding = plain
    pool_size = 2
    events = [
        {
            event = "on_client_connack"
        }
    ]
}

# #====================================================================
# # Exchange configuration for Embedded Messaging Queue
# #====================================================================
# # Initalize multiple MQ exchanger by giving them different name (mq1)
exchange_client.mq1 {
	# # Currently NanoMQ only support one MQ object. URL shall be exactly same.
	exchange_url = "tcp://127.0.0.1:10000"
	# # exchanges contains multiple MQ exchanger
	limit_frequency = 5
	exchange {
		# # MQTT Topic for filtering messages and saving to queue
		topic = "canspi",
		# # MQ name
		name = "canspi",
		streamType = 0,
		# # MQ category. Only support Ringbus for now
		ringbus = {
			# # ring buffer name
			name = "ringbus",
			# # max length of ring buffer (msg count)
			cap = 1000,
			# #  0: RB_FULL_NONE: When the ringbus is full, no action is taken and the message enqueue fail
			# #  1: RB_FULL_DROP: When the ringbus is full, the data in the ringbus is discarded
			# #  2: RB_FULL_RETURN: When the ringbus is full, the data in the ringbus is taken out and returned to the aio
			# #  3: RB_FULL_FILE: When the ringbus is full, the data in the ringbus is written to the file
			#
			# # Value: 0-4
			# # Default: 0
			# # Note: Sdv flow is only applicable to RB_FULL_RETURN(2)
			fullOp = 2
		}

		parquet {
			# # Parquet compress type.
			# #
			# # Value: uncompressed | snappy | gzip | brotli | zstd | lz4
			compress = zstd
			# # The dir for parquet files.
			# #
			# # Value: Folder
			dir = "./parquet/canspi"
			# # The prefix of parquet files written.
			# #
			# # Value: string
			file_name_prefix = "nanomq"
			# # Maximum rotation count of parquet files.
			# #
			# # Value: Number
			# # Default: 5
			file_count = 1500
			# # The max size of parquet file written.
			# #
			# # Default: 10M
			# # Value: Number
			# # Supported Unit: KB | MB | GB
			file_size = 100MB
			# # The max number of searches per second.
			# #
			# # Default: 5
			# # Value: Number
			limit_frequency = 5
		}
	}
	encryption {
		enable = true
		key = "a0958ba0214d6fa6"
	}
}

exchange_client.mq2 {
	# # Currently NanoMQ only support one MQ object. URL shall be exactly same.
	exchange_url = "tcp://127.0.0.1:10001"
	# # exchanges contains multiple MQ exchanger
	limit_frequency = 5
	exchange {
		# # MQTT Topic for filtering messages and saving to queue
		topic = "signal",
		# # MQ name
		name = "signal",
		streamType = 0,
		# # MQ category. Only support Ringbus for now
		ringbus = {
			# # ring buffer name
			name = "ringbus2",
			# # max length of ring buffer (msg count)
			cap = 1000,
			# #  0: RB_FULL_NONE: When the ringbus is full, no action is taken and the message enqueue fail
			# #  1: RB_FULL_DROP: When the ringbus is full, the data in the ringbus is discarded
			# #  2: RB_FULL_RETURN: When the ringbus is full, the data in the ringbus is taken out and returned to the aio
			# #  3: RB_FULL_FILE: When the ringbus is full, the data in the ringbus is written to the file
			#
			# # Value: 0-4
			# # Default: 0
			# # Note: Sdv flow is only applicable to RB_FULL_RETURN(2)
			fullOp = 2
		}

		parquet {
			# # Parquet compress type.
			# #
			# # Value: uncompressed | snappy | gzip | brotli | zstd | lz4
			compress = zstd
			# # The dir for parquet files.
			# #
			# # Value: Folder
			dir = "./parquet/signal"
			# # The prefix of parquet files written.
			# #
			# # Value: string
			file_name_prefix = "nanomq"
			# # Maximum rotation count of parquet files.
			# #
			# # Value: Number
			# # Default: 5
			file_count = 300
			# # The max size of parquet file written.
			# #
			# # Default: 10M
			# # Value: Number
			# # Supported Unit: KB | MB | GB
			file_size = 100MB
			# # The max number of searches per second.
			# #
			# # Default: 5
			# # Value: Number
			limit_frequency = 5
		}
	}
	encryption {
		enable = true
		key = "a0958ba0214d6fa6"
	}
}

exchange_client.mq3 {
	# # Currently NanoMQ only support one MQ object. URL shall be exactly same.
	exchange_url = "tcp://127.0.0.1:10002"
	# # exchanges contains multiple MQ exchanger
	limit_frequency = 5
	exchange {
		# # MQTT Topic for filtering messages and saving to queue
		topic = "battcell",
		# # MQ name
		name = "battcell",
		streamType = 0,
		# # MQ category. Only support Ringbus for now
		ringbus = {
			# # ring buffer name
			name = "ringbus3",
			# # max length of ring buffer (msg count)
			cap = 1000,
			# #  0: RB_FULL_NONE: When the ringbus is full, no action is taken and the message enqueue fail
			# #  1: RB_FULL_DROP: When the ringbus is full, the data in the ringbus is discarded
			# #  2: RB_FULL_RETURN: When the ringbus is full, the data in the ringbus is taken out and returned to the aio
			# #  3: RB_FULL_FILE: When the ringbus is full, the data in the ringbus is written to the file
			#
			# # Value: 0-4
			# # Default: 0
			# # Note: Sdv flow is only applicable to RB_FULL_RETURN(2)
			fullOp = 2
		}

		parquet {
			# # Parquet compress type.
			# #
			# # Value: uncompressed | snappy | gzip | brotli | zstd | lz4
			compress = zstd
			# # The dir for parquet files.
			# #
			# # Value: Folder
			dir = "./parquet/battcell"
			# # The prefix of parquet files written.
			# #
			# # Value: string
			file_name_prefix = "nanomq"
			# # Maximum rotation count of parquet files.
			# #
			# # Value: Number
			# # Default: 5
			file_count = 100
			# # The max size of parquet file written.
			# #
			# # Default: 10M
			# # Value: Number
			# # Supported Unit: KB | MB | GB
			file_size = 100MB
			# # The max number of searches per second.
			# #
			# # Default: 5
			# # Value: Number
			limit_frequency = 5
		}
	}
	encryption {
		enable = true
		key = "a0958ba0214d6fa6"
	}
}

exchange_client.mq4 {
	# # Currently NanoMQ only support one MQ object. URL shall be exactly same.
	exchange_url = "tcp://127.0.0.1:10003"
	# # exchanges contains multiple MQ exchanger
	limit_frequency = 5
	exchange {
		# # MQTT Topic for filtering messages and saving to queue
		topic = "batttsnsr",
		# # MQ name
		name = "batttsnsr",
		streamType = 0,
		# # MQ category. Only support Ringbus for now
		ringbus = {
			# # ring buffer name
			name = "ringbus4",
			# # max length of ring buffer (msg count)
			cap = 1000,
			# #  0: RB_FULL_NONE: When the ringbus is full, no action is taken and the message enqueue fail
			# #  1: RB_FULL_DROP: When the ringbus is full, the data in the ringbus is discarded
			# #  2: RB_FULL_RETURN: When the ringbus is full, the data in the ringbus is taken out and returned to the aio
			# #  3: RB_FULL_FILE: When the ringbus is full, the data in the ringbus is written to the file
			#
			# # Value: 0-4
			# # Default: 0
			# # Note: Sdv flow is only applicable to RB_FULL_RETURN(2)
			fullOp = 2
		}

		parquet {
			# # Parquet compress type.
			# #
			# # Value: uncompressed | snappy | gzip | brotli | zstd | lz4
			compress = zstd
			# # The dir for parquet files.
			# #
			# # Value: Folder
			dir = "./parquet/batttsnsr"
			# # The prefix of parquet files written.
			# #
			# # Value: string
			file_name_prefix = "nanomq"
			# # Maximum rotation count of parquet files.
			# #
			# # Value: Number
			# # Default: 5
			file_count = 300
			# # The max size of parquet file written.
			# #
			# # Default: 10M
			# # Value: Number
			# # Supported Unit: KB | MB | GB
			file_size = 100MB
			# # The max number of searches per second.
			# #
			# # Default: 5
			# # Value: Number
			limit_frequency = 5
		}
	}
	encryption {
		enable = true
		key = "a0958ba0214d6fa6"
	}
}
