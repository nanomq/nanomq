system {
	num_taskq_thread = 0
	max_taskq_thread = 0
	parallel = 0
	hook_ipc_url = "ipc:///tmp/nanomq_hook.ipc"
	cmd_ipc_url = "ipc:///tmp/nanomq_cmd.ipc"
	exchange_ipc_url = "ipc:///tmp/nanomq_exchange.ipc"
}

mqtt {
	max_packet_size = 20MB
	client_max_packet_size = 1054
	max_mqueue_len = 2048
	retry_interval = 10s
	keepalive_multiplier = 1.25
	property_size = 32
}

listeners.tcp {
	bind = "0.0.0.0:1883"
}

listeners.ssl {
	enable = false
	bind = "0.0.0.0:8883"
	# key_password="yourpass"
	keyfile = "/etc/certs/key.pem"
	certfile = "/etc/certs/cert.pem"
	cacertfile = "/etc/certs/cacert.pem"
	verify_peer = false
	fail_if_no_peer_cert = false
}

listeners.ws {
	enable = true
	bind = "0.0.0.0:8083/mqtt"
}

listeners.wss {
	enable = true
	bind = "0.0.0.0:8086/mqtt"
}

sqlite {
	disk_cache_size = 102400
	mounted_file_path="/tmp/"
	flush_mem_threshold = 100
	resend_interval = 5000
}

http_server {
	port = 8081
	ip_addr = "0.0.0.0"
	limit_conn = 32
	username = admin
	password = public
	auth_type = basic
	jwt {
		public.keyfile = "/etc/certs/jwt/jwtRS256.key.pub"
	}
}

log {
	to = [file, console]
	level = warn
	dir = "/tmp"
	file = "nanomq.log"
	rotation {
		size = 10MB
		count = 5
	}
}

webhook {
	enable = false
	url = "http://127.0.0.1:80"
	headers.content-type = "application/json"
	body.encoding = plain
	pool_size = 32
	
	events = [
		{ 
			event = "on_message_publish"
			topic = "a/b/c"
		}
		{
			event = "on_client_connack"
		}
	]
}

auth {
	allow_anonymous = true
	no_match = allow
	deny_action = ignore
	cache = {
		max_size = 32
		ttl = 1m
	}
	
	http_auth = {
		auth_req {
			enable = false
			url = "http://127.0.0.1:80/mqtt/auth"
			method = post
			headers.content-type = "application/x-www-form-urlencoded"
			params = {clientid = "%c", username = "%u", password = "%P"}
		}
		
		super_req {
			enable = false
			url = "http://127.0.0.1:80/mqtt/superuser"
			method = "post"
			headers.content-type = "application/x-www-form-urlencoded"
			params = {clientid = "%c", username = "%u", password = "%P", access = "%A", topic = "%t"}
		}
		acl_req {
			enable = false
			url = "http://127.0.0.1:8991/mqtt/acl"
			method = "post"
			headers.content-type = "application/x-www-form-urlencoded"
			params = {clientid = "%c", username = "%u", password = "%P", access = "%A", topic = "%t"}
		}
		enable = false
		timeout = 5s
		connect_timeout = 5s
		pool_size = 32
	}
	password {
		enable = false
		"admin": "XthBefJxR/AybhpEC3/fwwAAAAAAAAAAAAAAAAAAAAAfPPcY9MQ="
		"client": "XthBefJxR/AybhpEC3/fwwAAAAAAAAAAAAAAAAAAAAAfPPcY9MQ="
	}

	acl {
		enable = false
		rules = [
			{"permit": "allow", "username": "dashboard", "action": "subscribe", "topics": ["$SYS/#"]}

	        {"permit": "deny", "username": "#", "action": "subscribe", "topics": ["$SYS/#", "#"]}

	        {"permit": "allow"}
		]
	}
}

bridges.mqtt.emqx1 {
	enable = false
	server = "mqtt-tcp://127.0.0.1:1883"
	proto_ver = 5
	clientid="bridge_client"
	keepalive = 60s
	backoff_max = 60s
	clean_start = false
	transparent = false
	username = username
	password = passwd
	conn_properties = {
		maximum_packet_size = 1024
		receive_maximum = 65535
		topic_alias_maximum = 0
		request_problem_infomation = 1
		request_response_infomation = 0
		session_expiry_interval = 0
		user_property = {
			key1 = value1
			key2 = value2
		}
	}

	will {
		topic = "will_topic"
		qos = 1
		retain = false
		payload = "will_message"
		properties = {
			payload_format_indicator = 0
			message_expiry_interval = 0
			content_type = ""
			response_topic = ""
			correlation_data = ""
			will_delay_interval = 0
			user_property = {
				key1 = value1
				key2 = value2
			}
		}
	}

    ssl {
    	enable = false
        key_password = "yourpass"
        keyfile = "/etc/certs/key.pem"
        certfile = "/etc/certs/cert.pem"
        cacertfile = "/etc/certs/cacert.pem"
        cert_encrypted = false
    }
	forwards = [
		{

			remote_topic = "fwd/topic1"
			local_topic = "topic1"
			retain = 2
			prefix = ""
			suffix = ""
		}
		{
			remote_topic = "fwd/topic2"
			local_topic = "topic2"
			prefix = ""
			suffix = ""
		}
	]

	quic_keepalive = 120s
	quic_idle_timeout = 120s
	quic_discon_timeout = 20s
	quic_handshake_timeout = 60s
	quic_send_idle_timeout = 2s
	quic_initial_rtt_ms = 800ms
	quic_max_ack_delay_ms = 100ms
	quic_multi_stream = false
	quic_qos_priority = true
	quic_0rtt = true
	
	subscription = [
		{
			remote_topic = "cmd/topic3"
			local_topic = "topic3"
			qos = 1
			retain = 2
			retain_as_published = 1
			retain_handling = 2
			prefix = ""
			suffix = ""
		}
		{
			remote_topic = "cmd/topic4"
			local_topic = "topic4"
			qos = 2
		}
	]
	sub_properties {
		identifier = 1
		user_property = {
			key1 = value1
			key2 = value2
		}
	}

	hybrid_bridging = false
	hybrid_servers = ["mqtt-tcp://127.1.1.2:14567", "mqtt-tcp://127.1.1.3:1883"]
	max_parallel_processes = 2
	max_send_queue_len = 32
	max_recv_queue_len = 128
	resend_interval = 5000
	resend_wait = 3000
	cancel_timeout = 8000
	retry_qos_0 = false
}

bridges.mqtt.cache {
	disk_cache_size = 102400
	mounted_file_path="/tmp/"
	flush_mem_threshold = 100
}
